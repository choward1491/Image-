//
//  convex_hull3D.h
//  DataStructures
//
//  Created by Christian J Howard on 4/12/15.
//  Copyright (c) 2015 Christian Howard. All rights reserved.
//

#ifndef DataStructures_convex_hull3D_h
#define DataStructures_convex_hull3D_h


/*
 *
 *   TODO:
 *   Refactor and reimplement Convex Hull algorithm
 *
 *   To not attempt to use.
 *
 *
 */



/*
#include "AVL_Tree.hpp"
#include "Heap.hpp"
#include "hash_table.h"
#include "queue.h"
 */

#include <math.h>
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <unordered_map>
#include <map>





/*=======================================
 template function for assigning 3d arrays
 ========================================*/
template< typename T>
void assign( T p[], T x, T y, T z){
    p[0] = x;
    p[1] = y;
    p[2] = z;
}








/*=======================================
 This is a triangle class for use in the
 3D convex hull algorithm. The output will
 be all the triangles that create the 
 convex hull, so this is fairly important
 ========================================*/
template< typename T>
class Triangle{
    
public:
    
    // Numeric id for triangle
    int id;
    
    // indices of points that are the
    // vertices of this triangle
    int vertices[3];
    
    // the normal vector of the triangle
    T normal[3];
    
    // the ids the neighboring triangles
    int neighbors[3];
    
    
    
    
    /*=======================================
     Null constructor for triangle
     ========================================*/
    Triangle(){
        for (int i = 0; i < 3; i++ ) {
            vertices[i]  = -1;
            normal[i]    = T(0);
            neighbors[i] = -1;
        }
        id = -1;
    }
    
    
    
    
    
    /*=======================================
     method to generate the normal for the triangle
     ========================================*/
    void makeNormal( T *x, T *y, T *z, int num_pts ){
        
        int i1 = vertices[0];
        int i2 = vertices[1];
        int i3 = vertices[2];
        
        T u[] = { x[i2] - x[i1], y[i2] - y[i1], z[i2] - z[i1] };
        T v[] = { x[i3] - x[i1], y[i3] - y[i1], z[i3] - z[i1] };
        
        T N[3];
        N[0] = u[1]*v[2] - u[2]*v[1];
        N[1] = u[2]*v[0] - u[0]*v[2];
        N[2] = u[0]*v[1] - u[1]*v[0];
        T mag = sqrt( N[0]*N[0] + N[1]*N[1] + N[2]*N[2] );
        
        normal[0] = N[0] / mag;
        normal[1] = N[1] / mag;
        normal[2] = N[2] / mag;
    }
    
    
    
    bool pointWithinTriangle( T xt, T yt, const T *x, const T *y, int num_pts ) const{
        bool pointInTriangle = true;
        int i1 = vertices[0];
        int i2 = vertices[1];
        int i3 = vertices[2];
        
        T dx = xt - x[i1], dy = yt - y[i1];
        T dx1= x[i2] - x[i1], dy1 = y[i2] - y[i1];
        T dx2= x[i3] - x[i1], dy2 = y[i3] - y[i1];
        T detA = dx1*dy2 - dx2*dy1;
        T s = (dy2*dx - dx2*dy)/detA;
        T t = (-dy1*dx + dx1*dy)/detA;
        
        return s >= 0.0 && t >= 0.0 && (s + t <= 1.0);
        
    }
    
    
    /*=======================================
     method to check if this triangle shares
     the edge generated by the input points
     pt1 and pt2
     ========================================*/
    bool shareEdge( int pt1, int pt2 ){
        int count = 0;
        for (int i = 0; i < 3; i++) {
            count += (pt1 == vertices[i]) + (pt2 == vertices[i]);
        }
        
        return count == 2;
    }
    
    
    
    
    
    
    /*=======================================
     method to print the triangle inputs
     ========================================*/
    void print( T * x, T * y, T * z ){
        int i1 = vertices[0];
        int i2 = vertices[1];
        int i3 = vertices[2];
        T pt1[] = {x[i1], y[i1], z[i1]};
        T pt2[] = {x[i2], y[i2], z[i2]};
        T pt3[] = {x[i3], y[i3], z[i3]};
        
        std::cout << "Triangle: " << id << "\n";
        std::cout << "( " << pt1[0] <<", "<< pt1[1] << ", " << pt1[2] << " )\n";
        std::cout << "( " << pt2[0] <<", "<< pt2[1] << ", " << pt2[2] << " )\n";
        std::cout << "( " << pt3[0] <<", "<< pt3[1] << ", " << pt3[2] << " )\n\n";
    }
    
};







/*=======================================
 Convex Hull 3D hash function
 ========================================*/
/*int ch3d_hf(int key, int size){
    return key % size;
}*/


namespace std {
    
    template<typename T>
    struct greater< std::pair<T,int> > {
        
        bool operator()(const std::pair<T,int> &lhs,
                        const std::pair<T,int> &rhs) const
        {
            return lhs.first > rhs.first;
        }
        
    };
    
}



/*=======================================
 Convex Hull 3D class that will take
 an input set of (x,y,z) tuples and find
 the convex hull of the set
 ========================================*/
template< typename T >
class Convex_Hull3D {
    
public:
    
    /*=======================================
    Null constructor for 3D Convex Hull
    =========================================*/
    Convex_Hull3D();
    
    
    
    
    /*=======================================
    Constructor to initialize convex hull class
     based on the set of 3D data
    =========================================*/
    Convex_Hull3D( std::vector<T> & x_arr, std::vector<T> & y_arr );
    
    
    
    
    
    /*=======================================
     method to generate the 3D convex hull
    =========================================*/
    void generateConvexHull();
    
    
    
    
    
    /*=======================================
    function to output a vector parametrized
     by type T triangles
    =========================================*/
    void getData( std::vector< Triangle<T> > & out_struct ); // returns final data
    
    
private:
    
    /*=======================================
     Hash table storing the triangle data
     based on the triangle's id number
    =========================================*/
    typedef std::pair<T,int> chpair;
    typedef std::priority_queue<chpair, std::vector<chpair>, std::greater<chpair> > MaxHeap;
    //HashTable< int, Triangle<T>, AVL_Tree<int, Triangle<T>> > data;
    std::map<int, Triangle<T>> data;
    
    
    
    
    /*=======================================
     the number of 3D points in the data
    =========================================*/
    int num_pts;
    
    
    /*=======================================
     pointer to the x components of data points
    =========================================*/
    std::vector<T> * x;
    
    
    /*=======================================
     pointer to the y components of data points
    =========================================*/
    std::vector<T> * y;
    
    /*=======================================
     pointer to the z components of data points
    =========================================*/
    std::vector<T> z;
    
    
    
    
    
    
    
    
    /*=======================================
     Recursive method to generate the 3D
     convex hull
     
     <input> tri | 
             This is a pointer to a triangle
             class instance.
     
     <input> heap |
             This is a Max Heap based on the
             data that needs to be processed
             by this triangle. The heap is set
             up to already have the furthest 
             value from the triangle plane,
             with it being located at the root
     
    =========================================*/
    void getConvexHullHelper(Triangle<T> * tri, MaxHeap & heap );
    
    
    
    
    
    
    /*=======================================
     method to print the convex hull
     Note| This isn't implemented right now
     =========================================*/
    void printConvexHull() const;
    
    
    
    
    
    
    
    
    
    /*=======================================
     distance between two 3D points
    =========================================*/
    T dist_pt2pt( T pt1[], T pt2[] );
    
    
    /*=======================================
     min distance between line, defined by points
     'p1' and 'p2', and the 3D point 'p'
    =========================================*/
    T dist_line2pt( T p1[], T p2[], T p[]);
    
    
    /*=======================================
     min distance from plane, defined by
     a plane vertex 'ppt' and plane normal
     'normal', and 3D point p
    =========================================*/
    T dist_plane2pt( T ppt[], T normal[], T p[] );
    
    
    /*=======================================
    method to find center location of 3D point
      cloud defined by x, y, z pointers
    =========================================*/
    void getCenter( T center[] );
};










template< typename T >
Convex_Hull3D<T>::Convex_Hull3D():data(){
    x = 0;
    y = 0;
    z = 0;
    num_pts = 0;
}

template< typename T >
Convex_Hull3D<T>::Convex_Hull3D( std::vector<T> & x_arr, std::vector<T> & y_arr ):data(){
    x = &x_arr;
    y = &y_arr;
    z.resize(x_arr.size());
    for(int i = 0; i < x_arr.size(); ++i){ z[i] = x_arr[i]*x_arr[i] + y_arr[i]*y_arr[i]; }
    num_pts = x_arr.size();
    
}

template< typename T >
void Convex_Hull3D<T>::generateConvexHull(){
    
    if ( x != 0 ) {
        
        Triangle<T> tri1;
        Triangle<T> tri2;
        Triangle<T> tri3;
        Triangle<T> tri4;
        
        MaxHeap points1;
        MaxHeap points2;
        MaxHeap points3;
        MaxHeap points4;
        
        
        T pt1[3];
        int i1 = -1;
        
        T pt2[3];
        int i2 = -1;
        
        T pt3[3];
        int i3 = -1;
        
        T pt4[3];
        int i4 = -1;
        
        
        // Obtain the Center point
        T center[3];
        getCenter(center);
        
        
        // Find furthest point from the center
        T dist;
        T mdist = T(0);
        int mi = 0;
        
        for (int i = 0; i < num_pts; i++ ) {
            T pt[] = {(*x)[i], (*y)[i], z[i]};
            dist = dist_pt2pt(center, pt);
            
            if( dist > mdist ){
                mdist = dist;
                mi = i;
            }
        }
        
        
        assign<T>(pt1, (*x)[mi], (*y)[mi], z[mi]);
        i1 = mi;
        
        
        // Find furthest point from pt1
        mdist = T(0);
        for (int i = 0; i < num_pts; i++ ) {
            T pt[3] = {(*x)[i], (*y)[i], z[i]};
            dist = dist_pt2pt(pt1, pt);
            
            if( dist > mdist ){
                mdist = dist;
                mi = i;
            }
        }
        
        assign<T>(pt2, (*x)[mi], (*y)[mi], z[mi]);
        i2 = mi;
        
        
        
        // Find the furthest point from the line
        mdist = T(0);
        for (int i = 0; i < num_pts; i++ ) {
            T pt[3] = {(*x)[i], (*y)[i], z[i]};
            dist = dist_line2pt(pt1, pt2, pt);
            
            if( dist > mdist ){
                mdist = dist;
                mi = i;
            }
        }
        
        assign<T>(pt3, (*x)[mi], (*y)[mi], z[mi]);
        i3 = mi;
        
        
        
        // Find the furthest point from the triangle plane
        assign<int>(tri1.vertices, i1, i2, i3);
        tri1.makeNormal( &(*x)[0], &(*y)[0], &z[0], num_pts );
        
        mdist = T(0);
        int sign = 1;
        int msign = 1;
        
        for (int i = 0; i < num_pts; i++ ) {
            sign = 1;
            T pt[] = {(*x)[i], (*y)[i], z[i]};
            dist = dist_plane2pt(pt1, tri1.normal, pt);
            if ( dist < 0 ) {
                dist = -dist;
                sign = -1;
            }
            
            if( dist > mdist ){
                mdist = dist;
                mi = i;
                msign = sign;
            }
        }
        
        
        assign<T>(pt4, (*x)[mi], (*y)[mi], z[mi]);
        i4 = mi;
        
        
        // Check if one needs to change direction of tetrahedron vertices
        if (msign < 0) {
            // swap 1 and 3
            T tmp = pt1[0];
            pt1[0] = pt3[0];
            pt3[0] = tmp;
            
            tmp = pt1[1];
            pt1[1] = pt3[1];
            pt3[1] = tmp;
            
            tmp = pt1[2];
            pt1[2] = pt3[2];
            pt3[2] = tmp;
            
            
            int it = i1;
            i1 = i3;
            i3 = it;
        }
        
        
        
        
        /*===================================
         Generate the triangles' info
         ====================================*/
        
        // triangle vertices and id setup
        int id_cnt = 0;
        assign<int>(tri1.vertices, i1, i2, i4);
        tri1.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        tri1.id = id_cnt++;
        
        assign<int>(tri2.vertices, i2, i3, i4);
        tri2.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        tri2.id = id_cnt++;
        
        assign<int>(tri3.vertices, i3, i1, i4);
        tri3.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        tri3.id = id_cnt++;
        
        assign<int>(tri4.vertices, i3, i2, i1);
        tri4.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        tri4.id = id_cnt++;
        
        
        // triangle neighbors setup
        assign<int>(tri1.neighbors, 1, 2, 3);
        assign<int>(tri2.neighbors, 0, 2, 3);
        assign<int>(tri3.neighbors, 0, 1, 3);
        assign<int>(tri4.neighbors, 0, 1, 2);
        
        
        /*==============================================
         Find data that each triangle face will process
         ===============================================*/
        T dist1, dist2, dist3, dist4, pt[3], zero = T(0);
        
        
        
        for (int i = 0; i < num_pts; i++) {
            if( i != i1 && i != i2 && i != i3 && i != i4 ){
                
                pt[0] = (*x)[i];
                pt[1] = (*y)[i];
                pt[2] = z[i];
                
                dist1 = dist_plane2pt(pt2, tri1.normal, pt);
                dist2 = dist_plane2pt(pt2, tri2.normal, pt);
                dist3 = dist_plane2pt(pt3, tri3.normal, pt);
                dist4 = dist_plane2pt(pt3, tri4.normal, pt);
                
                if ( dist1 > zero ) {
                    points1.push( chpair(dist1, i) );
                }
                
                if (dist2 > zero ){
                    points2.push( chpair(dist2, i) );
                }
                
                if (dist3 > zero ){
                    points3.push( chpair(dist3, i) );
                }
                
                if (dist4 > zero ){
                    points4.push( chpair(dist4, i) );
                }
                
            }// end if i != statement
        }// end for loop
        
        
        // Add the triangles to the hash table
        data[tri1.id] = tri1;
        data[tri2.id] = tri2;
        data[tri3.id] = tri3;
        data[tri4.id] = tri4;
        
        
        // Do recursive Convex Hull obtaining algorithm
        /*getConvexHullHelper( &tri1, points1 );
        getConvexHullHelper( &tri2, points2 );
        getConvexHullHelper( &tri3, points3 );
        getConvexHullHelper( &tri4, points4 );*/
        
        std::stack<int>         tri_stack;
        std::stack<MaxHeap>     data_stack;
        
        if( points1.size() != 0 ){
            tri_stack.push(tri1.id);
            data_stack.push(points1);
        }
        
        if( points2.size() != 0 ){
            tri_stack.push(tri2.id);
            data_stack.push(points2);
        }
        
        if( points3.size() != 0 ){
            tri_stack.push(tri3.id);
            data_stack.push(points3);
        }
        
        if( points4.size() != 0 ){
            tri_stack.push(tri4.id);
            data_stack.push(points4);
        }
        
        
        while( tri_stack.size() != 0 ){
            
            // get reference to triangle
            Triangle<T> tri = data[tri_stack.top()]; tri_stack.pop();
            MaxHeap heap = data_stack.top(); data_stack.pop();
            
            // Get number of items in table
            int cnt = data.size();
            
            // Find the max point index
            int ind  = heap.top().second; heap.pop();
            int hcnt = heap.size();
            
            // Erase triangle from data list
            data.erase(tri.id);
            
            // Get copy of neighbors of input triangle
            Triangle<T> n1 = data[tri.neighbors[0]];
            Triangle<T> n2 = data[tri.neighbors[1]];
            Triangle<T> n3 = data[tri.neighbors[2]];
            
            /*==========================================
             Generate 4 new triangles based on the point
             and add them to the table
             ===========================================*/
            
            // Create 1st triangle
            Triangle<T> t1;
            t1.id = id_cnt++;
            
            // Create 2nd triangle
            Triangle<T> t2;
            t2.id = id_cnt++;
            
            // Create 3rd triangle
            Triangle<T> t3;
            t3.id = id_cnt++;
            
            
            
            
            // setup vertices t1
            t1.vertices[0] = tri.vertices[0];
            t1.vertices[1] = tri.vertices[1];
            t1.vertices[2] = ind;
            t1.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
            
            // setup vertices t2
            t2.vertices[0] = tri.vertices[1];
            t2.vertices[1] = tri.vertices[2];
            t2.vertices[2] = ind;
            t2.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
            
            // setup vertices t3
            t3.vertices[0] = tri.vertices[2];
            t3.vertices[1] = tri.vertices[0];
            t3.vertices[2] = ind;
            t3.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
            
            
            Triangle<T>* ptr = 0;
            std::queue<int> neighbor_inds;
            
            neighbor_inds.push(n1.id);
            neighbor_inds.push(n2.id);
            neighbor_inds.push(n3.id);
            
            // setup neighbors
            t1.neighbors[0] = t2.id;
            t1.neighbors[1] = t3.id;
            
            for (int i = 0; i < neighbor_inds.size(); i++ ) {
                int tmp = neighbor_inds.front(); neighbor_inds.pop();
                
                if ( tmp == n1.id ) {
                    ptr = &n1;
                }else if( tmp == n2.id ){
                    ptr = &n2;
                }else{
                    ptr = &n3;
                }
                
                if ( ptr->shareEdge( t1.vertices[0], t1.vertices[1] )) {
                    t1.neighbors[2] = ptr->id;
                    auto & n_tri = data[ptr->id];
                    for(int k = 0; k < 3; ++k){
                        if( n_tri.neighbors[k] == tri.id ){
                            n_tri.neighbors[k] = t1.id;
                            break;
                        }
                    }
                    break;
                }else{
                    neighbor_inds.push(tmp);
                }
            }
            
            // setup neighbors
            t2.neighbors[0] = t2.id;
            t2.neighbors[1] = t3.id;
            
            for (int i = 0; i < neighbor_inds.size(); i++ ) {
                int tmp = neighbor_inds.front(); neighbor_inds.pop();
                
                if ( tmp == n1.id ) {
                    ptr = &n1;
                }else if( tmp == n2.id ){
                    ptr = &n2;
                }else{
                    ptr = &n3;
                }
                
                if ( ptr->shareEdge( t2.vertices[0], t2.vertices[1] )) {
                    t2.neighbors[2] = ptr->id;
                    auto & n_tri = data[ptr->id];
                    for(int k = 0; k < 3; ++k){
                        if( n_tri.neighbors[k] == tri.id ){
                            n_tri.neighbors[k] = t1.id;
                            break;
                        }
                    }
                    break;
                }else{
                    neighbor_inds.push(tmp);
                }
            }
            
            // setup neighbors
            t3.neighbors[0] = t2.id;
            t3.neighbors[1] = t3.id;
            
            for (int i = 0; i < neighbor_inds.size(); i++ ) {
                int tmp = neighbor_inds.front(); neighbor_inds.pop();
                
                if ( tmp == n1.id ) {
                    ptr = &n1;
                }else if( tmp == n2.id ){
                    ptr = &n2;
                }else{
                    ptr = &n3;
                }
                
                if ( ptr->shareEdge( t3.vertices[0], t3.vertices[1] )) {
                    t3.neighbors[2] = ptr->id;
                    auto & n_tri = data[ptr->id];
                    for(int k = 0; k < 3; ++k){
                        if( n_tri.neighbors[k] == tri.id ){
                            n_tri.neighbors[k] = t1.id;
                            break;
                        }
                    }
                    break;
                }else{
                    neighbor_inds.push(tmp);
                }
            }
            
            
            data[t1.id] = t1;
            data[t2.id] = t2;
            data[t3.id] = t3;
            
            
            
            /*==========================================
             Find which data is left to be looked at by
             each triangle surface
             ===========================================*/
            
            if ( hcnt > 0 ){
                MaxHeap pts1;
                MaxHeap pts2;
                MaxHeap pts3;
                
                int i1 = t1.vertices[0];
                int i2 = t2.vertices[0];
                int i3 = t3.vertices[0];
                
                T pt1[] = { (*x)[i1], (*y)[i1], z[i1] };
                T pt2[] = { (*x)[i2], (*y)[i2], z[i2] };
                T pt3[] = { (*x)[i3], (*y)[i3], z[i3] };
                T pt[3];
                T zero = T(0);
                T dist1, dist2, dist3;
                
                // Find points to be processed
                for (int i = 0; i < hcnt; i++) {
                    int ind = heap.top().second; heap.pop();
                    
                    pt[0] = (*x)[ind];
                    pt[1] = (*y)[ind];
                    pt[2] = z[ind];
                    
                    dist1 = dist_plane2pt(pt1, t1.normal, pt);
                    dist2 = dist_plane2pt(pt2, t2.normal, pt);
                    dist3 = dist_plane2pt(pt3, t3.normal, pt);
                    
                    if ( dist1 > zero ) {
                        pts1.push( chpair(dist1, ind) );
                    }
                    
                    if (dist2 > zero ){
                        pts2.push( chpair(dist2, ind) );
                    }
                    
                    if (dist3 > zero ){
                        pts3.push( chpair(dist3, ind) );
                    }
                }// end for i hcnt loop
                
                
                
                // add items to stack
                if( pts1.size() != 0 ){
                    tri_stack.push(t1.id);
                    data_stack.push(pts1);
                }
                
                if( pts2.size() != 0 ){
                    tri_stack.push(t2.id);
                    data_stack.push(pts2);
                }
                
                if( pts3.size() != 0 ){
                    tri_stack.push(t3.id);
                    data_stack.push(pts3);
                }
            }
            
            
        }// end while
        
    }
    
}

template< typename T >
void Convex_Hull3D<T>::getData( std::vector< Triangle<T> > & out_struct ){
    /*
    for (int i = 0; i < data.getLengthTable(); i++ ) {
        vector< Triangle<T> > arr;
        data[i].getItems(arr);
        
        typename vector< Triangle<T> >::iterator it = arr.begin();
        for ( ; it != arr.end(); it++) {
            out_struct.push_back( *it );
        }
    }*/
    
    for( auto it = data.begin(); it != data.end(); ++it){
        out_struct.push_back(it->second);
    }
    
    
}

template< typename T >
void Convex_Hull3D<T>::printConvexHull() const{
    
}

template< typename T >
void Convex_Hull3D<T>::getConvexHullHelper(Triangle<T> * tri, MaxHeap & heap ){
    
    if ( heap.size() > 0 ) {
        
        // Get number of items in table
        int cnt = data.size();
        
        // Find the max point index
        int ind  = heap.top().second; heap.pop();
        int hcnt = heap.size();
        
        // Get copy of input triangle
        bool check = false;
        Triangle<T> old_tri = data[tri->id];
        data.erase(tri->id);
        
        // Get copy of neighbors of input triangle
        Triangle<T> n1 = data[tri->neighbors[0]];
        Triangle<T> n2 = data[tri->neighbors[1]];
        Triangle<T> n3 = data[tri->neighbors[2]];
        
        /*==========================================
         Generate 4 new triangles based on the point
         and add them to the table
         ===========================================*/
        
        // Create 1st triangle
        Triangle<T> t1;
        t1.id = cnt;
        
        // Create 2nd triangle
        Triangle<T> t2;
        t2.id = cnt+1;
        
        // Create 3rd triangle
        Triangle<T> t3;
        t3.id = cnt+2;
        
        
        
        
        // setup vertices t1
        t1.vertices[0] = tri->vertices[0];
        t1.vertices[1] = tri->vertices[1];
        t1.vertices[2] = ind;
        t1.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        
        // setup vertices t2
        t2.vertices[0] = tri->vertices[1];
        t2.vertices[1] = tri->vertices[2];
        t2.vertices[2] = ind;
        t2.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        
        // setup vertices t3
        t3.vertices[0] = tri->vertices[2];
        t3.vertices[1] = tri->vertices[0];
        t3.vertices[2] = ind;
        t3.makeNormal(&(*x)[0], &(*y)[0], &z[0], num_pts);
        
        
        Triangle<T>* ptr = 0;
        std::queue<int> neighbor_inds;
        
        neighbor_inds.push(n1.id);
        neighbor_inds.push(n2.id);
        neighbor_inds.push(n3.id);
        
        // setup neighbors
        t1.neighbors[0] = t2.id;
        t1.neighbors[1] = t3.id;
        
        for (int i = 0; i < neighbor_inds.size(); i++ ) {
            int tmp = neighbor_inds.front(); neighbor_inds.pop();
            
            if ( tmp == n1.id ) {
                ptr = &n1;
            }else if( tmp == n2.id ){
                ptr = &n2;
            }else{
                ptr = &n3;
            }
            
            if ( ptr->shareEdge( t1.vertices[0], t1.vertices[1] )) {
                t1.neighbors[2] = ptr->id;
                break;
            }else{
                neighbor_inds.push(tmp);
            }
        }
        
        // setup neighbors
        t2.neighbors[0] = t2.id;
        t2.neighbors[1] = t3.id;
        
        for (int i = 0; i < neighbor_inds.size(); i++ ) {
            int tmp = neighbor_inds.front(); neighbor_inds.pop();
            
            if ( tmp == n1.id ) {
                ptr = &n1;
            }else if( tmp == n2.id ){
                ptr = &n2;
            }else{
                ptr = &n3;
            }
            
            if ( ptr->shareEdge( t2.vertices[0], t2.vertices[1] )) {
                t2.neighbors[2] = ptr->id;
                break;
            }else{
                neighbor_inds.push(tmp);
            }
        }
        
        // setup neighbors
        t3.neighbors[0] = t2.id;
        t3.neighbors[1] = t3.id;
        
        for (int i = 0; i < neighbor_inds.size(); i++ ) {
            int tmp = neighbor_inds.front(); neighbor_inds.pop();
            
            if ( tmp == n1.id ) {
                ptr = &n1;
            }else if( tmp == n2.id ){
                ptr = &n2;
            }else{
                ptr = &n3;
            }
            
            if ( ptr->shareEdge( t3.vertices[0], t3.vertices[1] )) {
                t3.neighbors[2] = ptr->id;
                break;
            }else{
                neighbor_inds.push(tmp);
            }
        }
        
        
        data[t1.id] = t1;
        data[t2.id] = t2;
        data[t3.id] = t3;
        
        
        
        /*==========================================
         Find which data is left to be looked at by
         each triangle surface
         ===========================================*/
        
        if ( hcnt > 0 ){
            MaxHeap points1;
            MaxHeap points2;
            MaxHeap points3;
            
            int i1 = t1.vertices[0];
            int i2 = t2.vertices[0];
            int i3 = t3.vertices[0];
            
            T pt1[] = { (*x)[i1], (*y)[i1], z[i1] };
            T pt2[] = { (*x)[i2], (*y)[i2], z[i2] };
            T pt3[] = { (*x)[i3], (*y)[i3], z[i3] };
            T pt[3];
            T zero = T(0);
            T dist1, dist2, dist3;
            
            // Find points to be processed
            for (int i = 0; i < hcnt; i++) {
                int ind = heap.top().second; heap.pop();
                
                pt[0] = (*x)[ind];
                pt[1] = (*y)[ind];
                pt[2] = z[ind];
                
                dist1 = dist_plane2pt(pt1, t1.normal, pt);
                dist2 = dist_plane2pt(pt2, t2.normal, pt);
                dist3 = dist_plane2pt(pt3, t3.normal, pt);
                
                if ( dist1 > zero ) {
                    points1.push( chpair(dist1, ind) );
                }
                
                if (dist2 > zero ){
                    points2.push( chpair(dist2, ind) );
                }
                
                if (dist3 > zero ){
                    points3.push( chpair(dist3, ind) );
                }
            }// end for i hcnt loop
            
            
            
            // Do recursive calls
            getConvexHullHelper( &t1, points1 );
            getConvexHullHelper( &t2, points2 );
            getConvexHullHelper( &t3, points3 );
        }
    }
}


template< typename T >
T Convex_Hull3D<T>::dist_pt2pt( T pt1[], T pt2[] ){
    T dx  = pt1[0] - pt2[0];
    T dy  = pt1[1] - pt2[1];
    T dz  = pt1[2] - pt2[2];
    T mag = sqrt( dx*dx + dy*dy + dz*dz );
    
    return mag;
}

template< typename T >
T Convex_Hull3D<T>::dist_line2pt( T p1[], T p2[], T p[]){
    
    // Find relative vector along line
    T del[] = {p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]};
    
    // Find magnitude of relative vector along line
    T mag   = sqrt(del[0]*del[0] + del[1]*del[1] + del[2]*del[2]);
    
    // Generate unit vector along line
    T u[] = {del[0]/mag, del[1]/mag, del[2]/mag};
    
    // Find relative vector from starting point of line to point p
    assign<T>(del , p[0]-p1[0], p[1]-p1[1], p[2]-p1[2] );
    
    // Find dot product between del and u
    T dp = u[0]*del[0] + u[1]*del[1] + u[2]*del[2];
    
    // Find vector component of del perpendicular to u
    T d[3];
    d[0] = del[0] - dp * u[0];
    d[1] = del[1] - dp * u[1];
    d[2] = del[2] - dp * u[2];
    
    // Find magnitude of perpendicular component
    T dist = sqrt( d[0]*d[0] + d[1]*d[1] + d[2]*d[2] );
    
    return dist;
}

template< typename T >
T Convex_Hull3D<T>::dist_plane2pt( T ppt[], T normal[], T p[] ){
    T del[] = {p[0] - ppt[0], p[1] - ppt[1], p[2] - ppt[2]};
    
    T dp  = del[0]*normal[0] + del[1]*normal[1] + del[2]*normal[2];
    return dp;
}


template< typename T >
void Convex_Hull3D<T>::getCenter( T center[] ){
    
    T xavg = T(0);
    T yavg = T(0);
    T zavg = T(0);
    T num  = T(num_pts);
    
    for (int i = 0; i < num_pts; i++) {
        xavg += (*x)[i];
        yavg += (*y)[i];
        zavg += z[i];
    }
    
    xavg = xavg / num ;
    yavg = yavg / num ;
    zavg = zavg / num ;
    
    center[0] = xavg;
    center[1] = yavg;
    center[2] = zavg;
    
}





//#include "convex_hull3D.cpp"
    
#endif
